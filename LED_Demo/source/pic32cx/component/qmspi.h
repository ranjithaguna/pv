/**
 * \brief Component description for PIC32CX/0525SG12 QMSPI
 *
 * Copyright (c) 2018 Microchip Technology Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/* file generated from device description version 2018-04-24T21:15:30Z */
#ifndef _PIC32CX_0525SG12_QMSPI_COMPONENT_H_
#define _PIC32CX_0525SG12_QMSPI_COMPONENT_H_

/** \addtogroup PIC32CX_0525SG12_QMSPI The Quad SPI Master Controller may be used to communicate with various \n        peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs.\n        The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols.
 *  @{
 */
/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR QMSPI */
/* ========================================================================== */

/* -------- QMSPI_MODE : (QMSPI Offset: 0x00) (R/W 32) QMSPI Mode Register -------- */

typedef union
{
  struct
  {
    uint32_t ACTIVATE:1;                /**< bit:      0  This bit is used to activate the QMSPI block.\n     1=Enabled. The block is fully operational\n                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state. */
    uint32_t SOFT_RESET:1;              /**< bit:      1  Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing. */
    uint32_t :6;                        /**< bit:   2..7  Reserved                                      */
    uint32_t CPOL:1;                    /**< bit:      8  Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low. */
    uint32_t CHPA_MOSI:1;               /**< bit:      9  Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock\n                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock */
    uint32_t CHPA_MISO:1;               /**< bit:     10  Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock\n                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock */
    uint32_t :5;                        /**< bit: 11..15  Reserved                                      */
    uint32_t CLOCK_DIVIDE:9;            /**< bit: 16..24  The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256. */
    uint32_t :7;                        /**< bit: 25..31  Reserved                                      */
  };
  uint32_t w;
} __QMSPI_MODE_bits_t;
#define QMSPI_MODE_RESETVALUE               (0x0FU)                                       /**<  (QMSPI_MODE) QMSPI Mode Register  Reset Value */

#define QMSPI_MODE_ACTIVATE_Pos               (0)                                            /**< (QMSPI_MODE) This bit is used to activate the QMSPI block.\n     1=Enabled. The block is fully operational\n                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state. Position */
#define QMSPI_MODE_ACTIVATE_Msk               (0x1U << QMSPI_MODE_ACTIVATE_Pos)              /**< (QMSPI_MODE) This bit is used to activate the QMSPI block.\n     1=Enabled. The block is fully operational\n                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state. Mask */
#define QMSPI_MODE_SOFT_RESET_Pos             (1)                                            /**< (QMSPI_MODE) Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing. Position */
#define QMSPI_MODE_SOFT_RESET_Msk             (0x1U << QMSPI_MODE_SOFT_RESET_Pos)            /**< (QMSPI_MODE) Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing. Mask */
#define QMSPI_MODE_CPOL_Pos                   (8)                                            /**< (QMSPI_MODE) Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low. Position */
#define QMSPI_MODE_CPOL_Msk                   (0x1U << QMSPI_MODE_CPOL_Pos)                  /**< (QMSPI_MODE) Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low. Mask */
#define QMSPI_MODE_CHPA_MOSI_Pos              (9)                                            /**< (QMSPI_MODE) Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock\n                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock Position */
#define QMSPI_MODE_CHPA_MOSI_Msk              (0x1U << QMSPI_MODE_CHPA_MOSI_Pos)             /**< (QMSPI_MODE) Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock\n                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock Mask */
#define QMSPI_MODE_CHPA_MISO_Pos              (10)                                           /**< (QMSPI_MODE) Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock\n                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock Position */
#define QMSPI_MODE_CHPA_MISO_Msk              (0x1U << QMSPI_MODE_CHPA_MISO_Pos)             /**< (QMSPI_MODE) Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock\n                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock Mask */
#define QMSPI_MODE_CLOCK_DIVIDE_Pos           (16)                                           /**< (QMSPI_MODE) The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256. Position */
#define QMSPI_MODE_CLOCK_DIVIDE_Msk           (0x1FFU << QMSPI_MODE_CLOCK_DIVIDE_Pos)        /**< (QMSPI_MODE) The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256. Mask */
#define QMSPI_MODE_CLOCK_DIVIDE(value)        (QMSPI_MODE_CLOCK_DIVIDE_Msk & ((value) << QMSPI_MODE_CLOCK_DIVIDE_Pos))
#define QMSPI_MODE_Msk                        (0x01FF0703UL)                                 /**< (QMSPI_MODE) Register Mask  */

/* -------- QMSPI_CONTROL : (QMSPI Offset: 0x04) (R/W 32) QMSPI SPI Control -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either \n     TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.\n                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either\n     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes.\n     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer\n                 0=Receive is disabled */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface\n                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n                 1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes\n                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware */
    uint32_t CLOSE_TRANSFER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI \n     interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.\n     1=The transaction is terminated\n     0=The transaction is not terminated */
    uint32_t TRANSFER_UNITS:2;          /**< bit: 10..11  3=TRANSFER_LENGTH defined in units of 16-byte segments\n     2=TRANSFER_LENGTH defined in units of 4-byte segments\n     1=TRANSFER_LENGTH defined in units of bytes\n     0=TRANSFER_LENGTH defined in units of bits. */
    uint32_t DESCRIPTION_BUFFER_POINTER:4;  /**< bit: 12..15  This field selects the first buffer used if Description Buffers are enabled. */
    uint32_t DESCRIPTION_BUFFER_ENABLE:1;  /**< bit:     16  This enables the Description Buffers to be used.\n     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER\n     0=Description Buffers disabled. */
    uint32_t TRANSFER_LENGTH:15;        /**< bit: 17..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.\n     A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_CONTROL_bits_t;
#define QMSPI_CONTROL_RESETVALUE            (0x200U)                                      /**<  (QMSPI_CONTROL) QMSPI SPI Control  Reset Value */

#define QMSPI_CONTROL_INTERFACE_MODE_Pos      (0)                                            /**< (QMSPI_CONTROL) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either \n     TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_CONTROL_INTERFACE_MODE_Msk      (0x3U << QMSPI_CONTROL_INTERFACE_MODE_Pos)     /**< (QMSPI_CONTROL) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either \n     TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_CONTROL_INTERFACE_MODE(value)   (QMSPI_CONTROL_INTERFACE_MODE_Msk & ((value) << QMSPI_CONTROL_INTERFACE_MODE_Pos))
#define QMSPI_CONTROL_TX_TRANSFER_ENABLE_Pos  (2)                                            /**< (QMSPI_CONTROL) This field bit selects the transmit function of the SPI interface.\n                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.\n                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_CONTROL_TX_TRANSFER_ENABLE_Msk  (0x3U << QMSPI_CONTROL_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_CONTROL) This field bit selects the transmit function of the SPI interface.\n                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.\n                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_CONTROL_TX_TRANSFER_ENABLE(value) (QMSPI_CONTROL_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_CONTROL_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_CONTROL_TX_DMA_ENABLE_Pos       (4)                                            /**< (QMSPI_CONTROL) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either\n     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes.\n     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware Position */
#define QMSPI_CONTROL_TX_DMA_ENABLE_Msk       (0x3U << QMSPI_CONTROL_TX_DMA_ENABLE_Pos)      /**< (QMSPI_CONTROL) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either\n     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes.\n     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware Mask */
#define QMSPI_CONTROL_TX_DMA_ENABLE(value)    (QMSPI_CONTROL_TX_DMA_ENABLE_Msk & ((value) << QMSPI_CONTROL_TX_DMA_ENABLE_Pos))
#define QMSPI_CONTROL_RX_TRANSFER_ENABLE_Pos  (6)                                            /**< (QMSPI_CONTROL) This bit enables the receive function of the SPI interface.\n                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer\n                 0=Receive is disabled Position */
#define QMSPI_CONTROL_RX_TRANSFER_ENABLE_Msk  (0x1U << QMSPI_CONTROL_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_CONTROL) This bit enables the receive function of the SPI interface.\n                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer\n                 0=Receive is disabled Mask */
#define QMSPI_CONTROL_RX_DMA_ENABLE_Pos       (7)                                            /**< (QMSPI_CONTROL) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface\n                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n                 1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes\n                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware Position */
#define QMSPI_CONTROL_RX_DMA_ENABLE_Msk       (0x3U << QMSPI_CONTROL_RX_DMA_ENABLE_Pos)      /**< (QMSPI_CONTROL) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface\n                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n                 1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes\n                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware Mask */
#define QMSPI_CONTROL_RX_DMA_ENABLE(value)    (QMSPI_CONTROL_RX_DMA_ENABLE_Msk & ((value) << QMSPI_CONTROL_RX_DMA_ENABLE_Pos))
#define QMSPI_CONTROL_CLOSE_TRANSFER_ENABLE_Pos (9)                                            /**< (QMSPI_CONTROL) This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI \n     interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.\n     1=The transaction is terminated\n     0=The transaction is not terminated Position */
#define QMSPI_CONTROL_CLOSE_TRANSFER_ENABLE_Msk (0x1U << QMSPI_CONTROL_CLOSE_TRANSFER_ENABLE_Pos)  /**< (QMSPI_CONTROL) This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI \n     interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.\n     1=The transaction is terminated\n     0=The transaction is not terminated Mask */
#define QMSPI_CONTROL_TRANSFER_UNITS_Pos      (10)                                           /**< (QMSPI_CONTROL) 3=TRANSFER_LENGTH defined in units of 16-byte segments\n     2=TRANSFER_LENGTH defined in units of 4-byte segments\n     1=TRANSFER_LENGTH defined in units of bytes\n     0=TRANSFER_LENGTH defined in units of bits. Position */
#define QMSPI_CONTROL_TRANSFER_UNITS_Msk      (0x3U << QMSPI_CONTROL_TRANSFER_UNITS_Pos)     /**< (QMSPI_CONTROL) 3=TRANSFER_LENGTH defined in units of 16-byte segments\n     2=TRANSFER_LENGTH defined in units of 4-byte segments\n     1=TRANSFER_LENGTH defined in units of bytes\n     0=TRANSFER_LENGTH defined in units of bits. Mask */
#define QMSPI_CONTROL_TRANSFER_UNITS(value)   (QMSPI_CONTROL_TRANSFER_UNITS_Msk & ((value) << QMSPI_CONTROL_TRANSFER_UNITS_Pos))
#define QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER_Pos (12)                                           /**< (QMSPI_CONTROL) This field selects the first buffer used if Description Buffers are enabled. Position */
#define QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER_Msk (0xFU << QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER_Pos)  /**< (QMSPI_CONTROL) This field selects the first buffer used if Description Buffers are enabled. Mask */
#define QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER(value) (QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER_Msk & ((value) << QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER_Pos))
#define QMSPI_CONTROL_DESCRIPTION_BUFFER_ENABLE_Pos (16)                                           /**< (QMSPI_CONTROL) This enables the Description Buffers to be used.\n     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER\n     0=Description Buffers disabled. Position */
#define QMSPI_CONTROL_DESCRIPTION_BUFFER_ENABLE_Msk (0x1U << QMSPI_CONTROL_DESCRIPTION_BUFFER_ENABLE_Pos)  /**< (QMSPI_CONTROL) This enables the Description Buffers to be used.\n     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER\n     0=Description Buffers disabled. Mask */
#define QMSPI_CONTROL_TRANSFER_LENGTH_Pos     (17)                                           /**< (QMSPI_CONTROL) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.\n     A value of 0 means an infinite length transfer. Position */
#define QMSPI_CONTROL_TRANSFER_LENGTH_Msk     (0x7FFFU << QMSPI_CONTROL_TRANSFER_LENGTH_Pos)  /**< (QMSPI_CONTROL) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.\n     A value of 0 means an infinite length transfer. Mask */
#define QMSPI_CONTROL_TRANSFER_LENGTH(value)  (QMSPI_CONTROL_TRANSFER_LENGTH_Msk & ((value) << QMSPI_CONTROL_TRANSFER_LENGTH_Pos))
#define QMSPI_CONTROL_Msk                     (0xFFFFFFFFUL)                                 /**< (QMSPI_CONTROL) Register Mask  */

/* -------- QMSPI_EXECUTE : (QMSPI Offset: 0x08) (R/W 32) QMSPI Execute Register -------- */

typedef union
{
  struct
  {
    uint32_t START:1;                   /**< bit:      0  Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.\n     This bit must not be set to 1 if the field STOP in this register is set to 1. */
    uint32_t STOP:1;                    /**< bit:      1  Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.\n     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1. */
    uint32_t CLEAR_DATA_BUFFER:1;       /**< bit:      2  Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.\n     Writing a 0 to this bit has no effect. This bit is self clearing. */
    uint32_t :29;                       /**< bit:  3..31  Reserved                                      */
  };
  uint32_t w;
} __QMSPI_EXECUTE_bits_t;
#define QMSPI_EXECUTE_RESETVALUE            (0x01U)                                       /**<  (QMSPI_EXECUTE) QMSPI Execute Register  Reset Value */

#define QMSPI_EXECUTE_START_Pos               (0)                                            /**< (QMSPI_EXECUTE) Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.\n     This bit must not be set to 1 if the field STOP in this register is set to 1. Position */
#define QMSPI_EXECUTE_START_Msk               (0x1U << QMSPI_EXECUTE_START_Pos)              /**< (QMSPI_EXECUTE) Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.\n     This bit must not be set to 1 if the field STOP in this register is set to 1. Mask */
#define QMSPI_EXECUTE_STOP_Pos                (1)                                            /**< (QMSPI_EXECUTE) Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.\n     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1. Position */
#define QMSPI_EXECUTE_STOP_Msk                (0x1U << QMSPI_EXECUTE_STOP_Pos)               /**< (QMSPI_EXECUTE) Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.\n     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1. Mask */
#define QMSPI_EXECUTE_CLEAR_DATA_BUFFER_Pos   (2)                                            /**< (QMSPI_EXECUTE) Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.\n     Writing a 0 to this bit has no effect. This bit is self clearing. Position */
#define QMSPI_EXECUTE_CLEAR_DATA_BUFFER_Msk   (0x1U << QMSPI_EXECUTE_CLEAR_DATA_BUFFER_Pos)  /**< (QMSPI_EXECUTE) Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.\n     Writing a 0 to this bit has no effect. This bit is self clearing. Mask */
#define QMSPI_EXECUTE_Msk                     (0x00000007UL)                                 /**< (QMSPI_EXECUTE) Register Mask  */

/* -------- QMSPI_INTERFACE_CONTROL : (QMSPI Offset: 0x0c) (R/W 32) QMSPI Interface Control Register -------- */

typedef union
{
  struct
  {
    uint32_t WRITE_PROTECT_OUT_VALUE:1;  /**< bit:      0  This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.\n                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0 */
    uint32_t WRITE_PROTECT_OUT_ENABLE:1;  /**< bit:      1  1=WRITE PROTECT SPI Output Port is driven\n                 0=WRITE PROTECT SPI Output Port is not driven */
    uint32_t HOLD_OUT_VALUE:1;          /**< bit:      2  This bit sets the value on the HOLD SPI Output Port if it is driven.\n                 1=HOLD is driven to 1; 0=HOLD is driven to 0. */
    uint32_t HOLD_OUT_ENABLE:1;         /**< bit:      3  1=HOLD SPI Output Port is driven\n                 0=HOLD SPI Output Port is not driven. */
    uint32_t PULLDOWN_ON_NOT_SELECTED:1;  /**< bit:      4  1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-down resistors enabled on Receive pins */
    uint32_t PULLUP_ON_NOT_SELECTED:1;  /**< bit:      5  1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-up resistors enabled on Receive pins. */
    uint32_t PULLDOWN_ON_NOT_DRIVEN:1;  /**< bit:      6  1=Enable pull-down resistors on Transmit pins while the pins are not driven\n     0=No pull-down resistors enabled ion Transmit pins. */
    uint32_t PULLUP_ON_NOT_DRIVEN:1;    /**< bit:      7  1=Enable pull-up resistors on Transmit pins while the pins are not driven\n     0=No pull-up resistors enabled ion Transmit pins. */
    uint32_t :24;                       /**< bit:  8..31  Reserved                                      */
  };
  uint32_t w;
} __QMSPI_INTERFACE_CONTROL_bits_t;
#define QMSPI_INTERFACE_CONTROL_RESETVALUE  (0x25U)                                       /**<  (QMSPI_INTERFACE_CONTROL) QMSPI Interface Control Register  Reset Value */

#define QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_VALUE_Pos (0)                                            /**< (QMSPI_INTERFACE_CONTROL) This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.\n                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0 Position */
#define QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_VALUE_Msk (0x1U << QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_VALUE_Pos)  /**< (QMSPI_INTERFACE_CONTROL) This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.\n                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0 Mask */
#define QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_ENABLE_Pos (1)                                            /**< (QMSPI_INTERFACE_CONTROL) 1=WRITE PROTECT SPI Output Port is driven\n                 0=WRITE PROTECT SPI Output Port is not driven Position */
#define QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_ENABLE_Msk (0x1U << QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_ENABLE_Pos)  /**< (QMSPI_INTERFACE_CONTROL) 1=WRITE PROTECT SPI Output Port is driven\n                 0=WRITE PROTECT SPI Output Port is not driven Mask */
#define QMSPI_INTERFACE_CONTROL_HOLD_OUT_VALUE_Pos (2)                                            /**< (QMSPI_INTERFACE_CONTROL) This bit sets the value on the HOLD SPI Output Port if it is driven.\n                 1=HOLD is driven to 1; 0=HOLD is driven to 0. Position */
#define QMSPI_INTERFACE_CONTROL_HOLD_OUT_VALUE_Msk (0x1U << QMSPI_INTERFACE_CONTROL_HOLD_OUT_VALUE_Pos)  /**< (QMSPI_INTERFACE_CONTROL) This bit sets the value on the HOLD SPI Output Port if it is driven.\n                 1=HOLD is driven to 1; 0=HOLD is driven to 0. Mask */
#define QMSPI_INTERFACE_CONTROL_HOLD_OUT_ENABLE_Pos (3)                                            /**< (QMSPI_INTERFACE_CONTROL) 1=HOLD SPI Output Port is driven\n                 0=HOLD SPI Output Port is not driven. Position */
#define QMSPI_INTERFACE_CONTROL_HOLD_OUT_ENABLE_Msk (0x1U << QMSPI_INTERFACE_CONTROL_HOLD_OUT_ENABLE_Pos)  /**< (QMSPI_INTERFACE_CONTROL) 1=HOLD SPI Output Port is driven\n                 0=HOLD SPI Output Port is not driven. Mask */
#define QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_SELECTED_Pos (4)                                            /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-down resistors enabled on Receive pins Position */
#define QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_SELECTED_Msk (0x1U << QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_SELECTED_Pos)  /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-down resistors enabled on Receive pins Mask */
#define QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_SELECTED_Pos (5)                                            /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-up resistors enabled on Receive pins. Position */
#define QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_SELECTED_Msk (0x1U << QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_SELECTED_Pos)  /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-up resistors enabled on Receive pins. Mask */
#define QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_DRIVEN_Pos (6)                                            /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-down resistors on Transmit pins while the pins are not driven\n     0=No pull-down resistors enabled ion Transmit pins. Position */
#define QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_DRIVEN_Msk (0x1U << QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_DRIVEN_Pos)  /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-down resistors on Transmit pins while the pins are not driven\n     0=No pull-down resistors enabled ion Transmit pins. Mask */
#define QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_DRIVEN_Pos (7)                                            /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-up resistors on Transmit pins while the pins are not driven\n     0=No pull-up resistors enabled ion Transmit pins. Position */
#define QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_DRIVEN_Msk (0x1U << QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_DRIVEN_Pos)  /**< (QMSPI_INTERFACE_CONTROL) 1=Enable pull-up resistors on Transmit pins while the pins are not driven\n     0=No pull-up resistors enabled ion Transmit pins. Mask */
#define QMSPI_INTERFACE_CONTROL_Msk           (0x000000FFUL)                                 /**< (QMSPI_INTERFACE_CONTROL) Register Mask  */

/* -------- QMSPI_STATUS : (QMSPI Offset: 0x10) (R/W 32) QMSPI Status Register -------- */

typedef union
{
  struct
  {
    uint32_t TRANSFER_COMPLETE:1;       /**< bit:      0  In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.\n                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.\n     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.\n                 1=Transfer completed; 0=Transfer not complete. */
    uint32_t DMA_COMPLETE:1;            /**< bit:      1  This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.\n     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are\n      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.\n     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.\n                 1=DMA completed; 0=DMA not completed. */
    uint32_t TRANSMIT_BUFFER_ERROR:1;   /**< bit:      2  1=Overflow error occurred (attempt to write to a full Transmit Buffer)\n                 0=No overflow occurred. */
    uint32_t RECEIVE_BUFFER_ERROR:1;    /**< bit:      3  1=Underflow error occurred (attempt to read from an empty Receive Buffer)\n                 0=No underflow occurred. */
    uint32_t PROGRAMMING_ERROR:1;       /**< bit:      4  This bit if a programming error is detected.\n     1=Programming Error detected; 0=No programming error detected. */
    uint32_t :3;                        /**< bit:   5..7  Reserved                                      */
    uint32_t TRANSMIT_BUFFER_FULL:1;    /**< bit:      8  1=The Transmit Buffer is full\n     0=The Transmit Buffer is not full. */
    uint32_t TRANSMIT_BUFFER_EMPTY:1;   /**< bit:      9  1=The Transmit Buffer is empty\n     0=The Transmit Buffer is not empty. */
    uint32_t TRANSMIT_BUFFER_REQUEST:1;  /**< bit:     10  This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.\n     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER. */
    uint32_t TRANSMIT_BUFFER_STALL:1;   /**< bit:     11  1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)\n     0=No stalls occurred. */
    uint32_t RECEIVE_BUFFER_FULL:1;     /**< bit:     12  1=The Receive Buffer is full\n     0=The Receive Buffer is not full. */
    uint32_t RECEIVE_BUFFER_EMPTY:1;    /**< bit:     13  1=The Receive Buffer is empty\n     0=The Receive Buffer is not empty. */
    uint32_t RECEIVE_BUFFER_REQUEST:1;  /**< bit:     14  This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.\n                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER\n                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER. */
    uint32_t RECEIVE_BUFFER_STALL:1;    /**< bit:     15  1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)\n     0=No stalls occurred. */
    uint32_t TRANSFER_ACTIVE:1;         /**< bit:     16  1=A transfer is currently executing\n     0=No transfer currently in progress. */
    uint32_t :7;                        /**< bit: 17..23  Reserved                                      */
    uint32_t CURRENT_DESCRIPTION_BUFFER:4;  /**< bit: 24..27  This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled. */
    uint32_t :4;                        /**< bit: 28..31  Reserved                                      */
  };
  uint32_t w;
} __QMSPI_STATUS_bits_t;
#define QMSPI_STATUS_RESETVALUE             (0x2000U)                                     /**<  (QMSPI_STATUS) QMSPI Status Register  Reset Value */

#define QMSPI_STATUS_TRANSFER_COMPLETE_Pos    (0)                                            /**< (QMSPI_STATUS) In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.\n                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.\n     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.\n                 1=Transfer completed; 0=Transfer not complete. Position */
#define QMSPI_STATUS_TRANSFER_COMPLETE_Msk    (0x1U << QMSPI_STATUS_TRANSFER_COMPLETE_Pos)   /**< (QMSPI_STATUS) In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.\n                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.\n     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.\n                 1=Transfer completed; 0=Transfer not complete. Mask */
#define QMSPI_STATUS_DMA_COMPLETE_Pos         (1)                                            /**< (QMSPI_STATUS) This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.\n     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are\n      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.\n     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.\n                 1=DMA completed; 0=DMA not completed. Position */
#define QMSPI_STATUS_DMA_COMPLETE_Msk         (0x1U << QMSPI_STATUS_DMA_COMPLETE_Pos)        /**< (QMSPI_STATUS) This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.\n     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are\n      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.\n     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.\n                 1=DMA completed; 0=DMA not completed. Mask */
#define QMSPI_STATUS_TRANSMIT_BUFFER_ERROR_Pos (2)                                            /**< (QMSPI_STATUS) 1=Overflow error occurred (attempt to write to a full Transmit Buffer)\n                 0=No overflow occurred. Position */
#define QMSPI_STATUS_TRANSMIT_BUFFER_ERROR_Msk (0x1U << QMSPI_STATUS_TRANSMIT_BUFFER_ERROR_Pos)  /**< (QMSPI_STATUS) 1=Overflow error occurred (attempt to write to a full Transmit Buffer)\n                 0=No overflow occurred. Mask */
#define QMSPI_STATUS_RECEIVE_BUFFER_ERROR_Pos (3)                                            /**< (QMSPI_STATUS) 1=Underflow error occurred (attempt to read from an empty Receive Buffer)\n                 0=No underflow occurred. Position */
#define QMSPI_STATUS_RECEIVE_BUFFER_ERROR_Msk (0x1U << QMSPI_STATUS_RECEIVE_BUFFER_ERROR_Pos)  /**< (QMSPI_STATUS) 1=Underflow error occurred (attempt to read from an empty Receive Buffer)\n                 0=No underflow occurred. Mask */
#define QMSPI_STATUS_PROGRAMMING_ERROR_Pos    (4)                                            /**< (QMSPI_STATUS) This bit if a programming error is detected.\n     1=Programming Error detected; 0=No programming error detected. Position */
#define QMSPI_STATUS_PROGRAMMING_ERROR_Msk    (0x1U << QMSPI_STATUS_PROGRAMMING_ERROR_Pos)   /**< (QMSPI_STATUS) This bit if a programming error is detected.\n     1=Programming Error detected; 0=No programming error detected. Mask */
#define QMSPI_STATUS_TRANSMIT_BUFFER_FULL_Pos (8)                                            /**< (QMSPI_STATUS) 1=The Transmit Buffer is full\n     0=The Transmit Buffer is not full. Position */
#define QMSPI_STATUS_TRANSMIT_BUFFER_FULL_Msk (0x1U << QMSPI_STATUS_TRANSMIT_BUFFER_FULL_Pos)  /**< (QMSPI_STATUS) 1=The Transmit Buffer is full\n     0=The Transmit Buffer is not full. Mask */
#define QMSPI_STATUS_TRANSMIT_BUFFER_EMPTY_Pos (9)                                            /**< (QMSPI_STATUS) 1=The Transmit Buffer is empty\n     0=The Transmit Buffer is not empty. Position */
#define QMSPI_STATUS_TRANSMIT_BUFFER_EMPTY_Msk (0x1U << QMSPI_STATUS_TRANSMIT_BUFFER_EMPTY_Pos)  /**< (QMSPI_STATUS) 1=The Transmit Buffer is empty\n     0=The Transmit Buffer is not empty. Mask */
#define QMSPI_STATUS_TRANSMIT_BUFFER_REQUEST_Pos (10)                                           /**< (QMSPI_STATUS) This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.\n     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER. Position */
#define QMSPI_STATUS_TRANSMIT_BUFFER_REQUEST_Msk (0x1U << QMSPI_STATUS_TRANSMIT_BUFFER_REQUEST_Pos)  /**< (QMSPI_STATUS) This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.\n     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER. Mask */
#define QMSPI_STATUS_TRANSMIT_BUFFER_STALL_Pos (11)                                           /**< (QMSPI_STATUS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)\n     0=No stalls occurred. Position */
#define QMSPI_STATUS_TRANSMIT_BUFFER_STALL_Msk (0x1U << QMSPI_STATUS_TRANSMIT_BUFFER_STALL_Pos)  /**< (QMSPI_STATUS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)\n     0=No stalls occurred. Mask */
#define QMSPI_STATUS_RECEIVE_BUFFER_FULL_Pos  (12)                                           /**< (QMSPI_STATUS) 1=The Receive Buffer is full\n     0=The Receive Buffer is not full. Position */
#define QMSPI_STATUS_RECEIVE_BUFFER_FULL_Msk  (0x1U << QMSPI_STATUS_RECEIVE_BUFFER_FULL_Pos)  /**< (QMSPI_STATUS) 1=The Receive Buffer is full\n     0=The Receive Buffer is not full. Mask */
#define QMSPI_STATUS_RECEIVE_BUFFER_EMPTY_Pos (13)                                           /**< (QMSPI_STATUS) 1=The Receive Buffer is empty\n     0=The Receive Buffer is not empty. Position */
#define QMSPI_STATUS_RECEIVE_BUFFER_EMPTY_Msk (0x1U << QMSPI_STATUS_RECEIVE_BUFFER_EMPTY_Pos)  /**< (QMSPI_STATUS) 1=The Receive Buffer is empty\n     0=The Receive Buffer is not empty. Mask */
#define QMSPI_STATUS_RECEIVE_BUFFER_REQUEST_Pos (14)                                           /**< (QMSPI_STATUS) This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.\n                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER\n                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER. Position */
#define QMSPI_STATUS_RECEIVE_BUFFER_REQUEST_Msk (0x1U << QMSPI_STATUS_RECEIVE_BUFFER_REQUEST_Pos)  /**< (QMSPI_STATUS) This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.\n                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER\n                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER. Mask */
#define QMSPI_STATUS_RECEIVE_BUFFER_STALL_Pos (15)                                           /**< (QMSPI_STATUS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)\n     0=No stalls occurred. Position */
#define QMSPI_STATUS_RECEIVE_BUFFER_STALL_Msk (0x1U << QMSPI_STATUS_RECEIVE_BUFFER_STALL_Pos)  /**< (QMSPI_STATUS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)\n     0=No stalls occurred. Mask */
#define QMSPI_STATUS_TRANSFER_ACTIVE_Pos      (16)                                           /**< (QMSPI_STATUS) 1=A transfer is currently executing\n     0=No transfer currently in progress. Position */
#define QMSPI_STATUS_TRANSFER_ACTIVE_Msk      (0x1U << QMSPI_STATUS_TRANSFER_ACTIVE_Pos)     /**< (QMSPI_STATUS) 1=A transfer is currently executing\n     0=No transfer currently in progress. Mask */
#define QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER_Pos (24)                                           /**< (QMSPI_STATUS) This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled. Position */
#define QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER_Msk (0xFU << QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER_Pos)  /**< (QMSPI_STATUS) This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled. Mask */
#define QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER(value) (QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER_Msk & ((value) << QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER_Pos))
#define QMSPI_STATUS_Msk                      (0x0F01FF1FUL)                                 /**< (QMSPI_STATUS) Register Mask  */

/* -------- QMSPI_BUFFER_COUNT_STATUS : (QMSPI Offset: 0x14) (R/W 32) QMSPI Buffer Count Status Register -------- */

typedef union
{
  struct
  {
    uint32_t TRANSMIT_BUFFER_COUNT:16;  /**< bit:  0..15  This is a count of the number of bytes currently valid in the Transmit Buffer. */
    uint32_t RECEIVE_BUFFER_COUNT:16;   /**< bit: 16..31  This is a count of the number of bytes currently valid in the Receive Buffer. */
  };
  uint32_t w;
} __QMSPI_BUFFER_COUNT_STATUS_bits_t;
#define QMSPI_BUFFER_COUNT_STATUS_RESETVALUE (0x00U)                                       /**<  (QMSPI_BUFFER_COUNT_STATUS) QMSPI Buffer Count Status Register  Reset Value */

#define QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT_Pos (0)                                            /**< (QMSPI_BUFFER_COUNT_STATUS) This is a count of the number of bytes currently valid in the Transmit Buffer. Position */
#define QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT_Msk (0xFFFFU << QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT_Pos)  /**< (QMSPI_BUFFER_COUNT_STATUS) This is a count of the number of bytes currently valid in the Transmit Buffer. Mask */
#define QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT(value) (QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT_Msk & ((value) << QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT_Pos))
#define QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT_Pos (16)                                           /**< (QMSPI_BUFFER_COUNT_STATUS) This is a count of the number of bytes currently valid in the Receive Buffer. Position */
#define QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT_Msk (0xFFFFU << QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT_Pos)  /**< (QMSPI_BUFFER_COUNT_STATUS) This is a count of the number of bytes currently valid in the Receive Buffer. Mask */
#define QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT(value) (QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT_Msk & ((value) << QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT_Pos))
#define QMSPI_BUFFER_COUNT_STATUS_Msk         (0xFFFFFFFFUL)                                 /**< (QMSPI_BUFFER_COUNT_STATUS) Register Mask  */

/* -------- QMSPI_INTERRUPT_ENABLE : (QMSPI Offset: 0x18) (R/W 32) QMSPI Interrupt Enable Register -------- */

typedef union
{
  struct
  {
    uint32_t TRANSFER_COMPLETE_ENABLE:1;  /**< bit:      0  1=Enable an interrupt if TRANSFER_COMPLETE is asserted\n     0=Disable the interrupt. */
    uint32_t DMA_COMPLETE_ENABLE:1;     /**< bit:      1  1=Enable an interrupt if DMA_COMPLETE is asserted\n     0=Disable the interrupt. */
    uint32_t TRANSMIT_BUFFER_ERROR_ENABLE:1;  /**< bit:      2  1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted\n     0=Disable the interrupt. */
    uint32_t RECEIVE_BUFFER_ERROR_ENABLE:1;  /**< bit:      3  1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted\n     0=Disable the interrupt. */
    uint32_t PROGRAMMING_ERROR_ENABLE:1;  /**< bit:      4  1=Enable an interrupt if PROGRAMMING_ERROR is asserted\n     0=Disable the interrupt. */
    uint32_t :3;                        /**< bit:   5..7  Reserved                                      */
    uint32_t TRANSMIT_BUFFER_FULL_ENABLE:1;  /**< bit:      8  1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted\n     0=Disable the interrupt. */
    uint32_t TRANSMIT_BUFFER_EMPTY_ENABLE:1;  /**< bit:      9  1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. */
    uint32_t TRANSMIT_BUFFER_REQUEST_ENABLE:1;  /**< bit:     10  1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. */
    uint32_t :1;                        /**< bit:     11  Reserved                                      */
    uint32_t RECEIVE_BUFFER_FULL_ENABLE:1;  /**< bit:     12  1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted\n     0=Disable the interrupt. */
    uint32_t RECEIVE_BUFFER_EMPTY_ENABLE:1;  /**< bit:     13  1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. */
    uint32_t RECEIVE_BUFFER_REQUEST_ENABLE:1;  /**< bit:     14  1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. */
    uint32_t :17;                       /**< bit: 15..31  Reserved                                      */
  };
  uint32_t w;
} __QMSPI_INTERRUPT_ENABLE_bits_t;
#define QMSPI_INTERRUPT_ENABLE_RESETVALUE   (0x2000U)                                     /**<  (QMSPI_INTERRUPT_ENABLE) QMSPI Interrupt Enable Register  Reset Value */

#define QMSPI_INTERRUPT_ENABLE_TRANSFER_COMPLETE_ENABLE_Pos (0)                                            /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSFER_COMPLETE is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_TRANSFER_COMPLETE_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_TRANSFER_COMPLETE_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSFER_COMPLETE is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_DMA_COMPLETE_ENABLE_Pos (1)                                            /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if DMA_COMPLETE is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_DMA_COMPLETE_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_DMA_COMPLETE_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if DMA_COMPLETE is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_ERROR_ENABLE_Pos (2)                                            /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_ERROR_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_ERROR_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_ERROR_ENABLE_Pos (3)                                            /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_ERROR_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_ERROR_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_PROGRAMMING_ERROR_ENABLE_Pos (4)                                            /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if PROGRAMMING_ERROR is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_PROGRAMMING_ERROR_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_PROGRAMMING_ERROR_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if PROGRAMMING_ERROR is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_FULL_ENABLE_Pos (8)                                            /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_FULL_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_FULL_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_EMPTY_ENABLE_Pos (9)                                            /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_EMPTY_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_EMPTY_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_REQUEST_ENABLE_Pos (10)                                           /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_REQUEST_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_REQUEST_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_FULL_ENABLE_Pos (12)                                           /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_FULL_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_FULL_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_EMPTY_ENABLE_Pos (13)                                           /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_EMPTY_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_EMPTY_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_REQUEST_ENABLE_Pos (14)                                           /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_REQUEST_ENABLE_Msk (0x1U << QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_REQUEST_ENABLE_Pos)  /**< (QMSPI_INTERRUPT_ENABLE) 1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_INTERRUPT_ENABLE_Msk            (0x0000771FUL)                                 /**< (QMSPI_INTERRUPT_ENABLE) Register Mask  */

/* -------- QMSPI_BUFFER_COUNT_TRIGGER : (QMSPI Offset: 0x1c) (R/W 32) QMSPI Buffer Count Trigger Register -------- */

typedef union
{
  struct
  {
    uint32_t TRANSMIT_BUFFER_TRIGGER:16;  /**< bit:  0..15  An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt. */
    uint32_t RECEIVE_BUFFER_TRIGGER:16;  /**< bit: 16..31  An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt. */
  };
  uint32_t w;
} __QMSPI_BUFFER_COUNT_TRIGGER_bits_t;
#define QMSPI_BUFFER_COUNT_TRIGGER_RESETVALUE (0x00U)                                       /**<  (QMSPI_BUFFER_COUNT_TRIGGER) QMSPI Buffer Count Trigger Register  Reset Value */

#define QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER_Pos (0)                                            /**< (QMSPI_BUFFER_COUNT_TRIGGER) An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt. Position */
#define QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER_Msk (0xFFFFU << QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER_Pos)  /**< (QMSPI_BUFFER_COUNT_TRIGGER) An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt. Mask */
#define QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER(value) (QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER_Msk & ((value) << QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER_Pos))
#define QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER_Pos (16)                                           /**< (QMSPI_BUFFER_COUNT_TRIGGER) An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt. Position */
#define QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER_Msk (0xFFFFU << QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER_Pos)  /**< (QMSPI_BUFFER_COUNT_TRIGGER) An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt. Mask */
#define QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER(value) (QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER_Msk & ((value) << QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER_Pos))
#define QMSPI_BUFFER_COUNT_TRIGGER_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_BUFFER_COUNT_TRIGGER) Register Mask  */

/* -------- QMSPI_TRAMSMIT_BUFFER : (QMSPI Offset: 0x20) (R/W 32) QMSPI Transmit Buffer Register -------- */

typedef union
{
  struct
  {
    uint32_t TRANSMIT_BUFFER:32;        /**< bit:  0..31  Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field. */
  };
  uint32_t w;
} __QMSPI_TRAMSMIT_BUFFER_bits_t;
#define QMSPI_TRAMSMIT_BUFFER_RESETVALUE    (0x00U)                                       /**<  (QMSPI_TRAMSMIT_BUFFER) QMSPI Transmit Buffer Register  Reset Value */

#define QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER_Pos (0)                                            /**< (QMSPI_TRAMSMIT_BUFFER) Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field. Position */
#define QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER_Msk (0xFFFFFFFFU << QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER_Pos)  /**< (QMSPI_TRAMSMIT_BUFFER) Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field. Mask */
#define QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER(value) (QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER_Msk & ((value) << QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER_Pos))
#define QMSPI_TRAMSMIT_BUFFER_Msk             (0xFFFFFFFFUL)                                 /**< (QMSPI_TRAMSMIT_BUFFER) Register Mask  */

/* -------- QMSPI_RECEIVE_BUFFER : (QMSPI Offset: 0x24) (R/W 32) QMSPI Receive Buffer Register -------- */

typedef union
{
  struct
  {
    uint32_t RECEIVE_BUFFER:32;         /**< bit:  0..31  Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field. */
  };
  uint32_t w;
} __QMSPI_RECEIVE_BUFFER_bits_t;
#define QMSPI_RECEIVE_BUFFER_RESETVALUE     (0x00U)                                       /**<  (QMSPI_RECEIVE_BUFFER) QMSPI Receive Buffer Register  Reset Value */

#define QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER_Pos (0)                                            /**< (QMSPI_RECEIVE_BUFFER) Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field. Position */
#define QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER_Msk (0xFFFFFFFFU << QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER_Pos)  /**< (QMSPI_RECEIVE_BUFFER) Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field. Mask */
#define QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER(value) (QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER_Msk & ((value) << QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER_Pos))
#define QMSPI_RECEIVE_BUFFER_Msk              (0xFFFFFFFFUL)                                 /**< (QMSPI_RECEIVE_BUFFER) Register Mask  */

/* -------- QMSPI_CS_TIMING_REG : (QMSPI Offset: 0x28) (R/W 32) QMSPI Chip Select Timing Register -------- */

typedef union
{
  struct
  {
    uint32_t DLY_CS_ON_TO_CLOCK_START:4;  /**< bit:   0..3                                                */
    uint32_t :4;                        /**< bit:   4..7  Reserved                                      */
    uint32_t DLY_CLK_STOP_TO_CS_OFF:4;  /**< bit:  8..11  This selects the number of system clock cycles between the last clock edge and the deassertion of CS.\n */
    uint32_t :4;                        /**< bit: 12..15  Reserved                                      */
    uint32_t DLY_LAST_DATA_HOLD:4;      /**< bit: 16..19  This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD \n    switching from input to output. This is only used if the WP/HOLD functions are in use and only on IO2/WP \n           and IO3/HOLD pins. */
    uint32_t :3;                        /**< bit: 20..22  Reserved                                      */
    uint32_t DLY_CS_OFF_TO_CS_ON:9;     /**< bit: 23..31  This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum \n           pulse width of CS deassertion. */
  };
  uint32_t w;
} __QMSPI_CS_TIMING_REG_bits_t;
#define QMSPI_CS_TIMING_REG_RESETVALUE      (0x6060406U)                                  /**<  (QMSPI_CS_TIMING_REG) QMSPI Chip Select Timing Register  Reset Value */

#define QMSPI_CS_TIMING_REG_DLY_CS_ON_TO_CLOCK_START_Pos (0)                                            /**< (QMSPI_CS_TIMING_REG)  Position */
#define QMSPI_CS_TIMING_REG_DLY_CS_ON_TO_CLOCK_START_Msk (0xFU << QMSPI_CS_TIMING_REG_DLY_CS_ON_TO_CLOCK_START_Pos)  /**< (QMSPI_CS_TIMING_REG)  Mask */
#define QMSPI_CS_TIMING_REG_DLY_CS_ON_TO_CLOCK_START(value) (QMSPI_CS_TIMING_REG_DLY_CS_ON_TO_CLOCK_START_Msk & ((value) << QMSPI_CS_TIMING_REG_DLY_CS_ON_TO_CLOCK_START_Pos))
#define QMSPI_CS_TIMING_REG_DLY_CLK_STOP_TO_CS_OFF_Pos (8)                                            /**< (QMSPI_CS_TIMING_REG) This selects the number of system clock cycles between the last clock edge and the deassertion of CS.\n Position */
#define QMSPI_CS_TIMING_REG_DLY_CLK_STOP_TO_CS_OFF_Msk (0xFU << QMSPI_CS_TIMING_REG_DLY_CLK_STOP_TO_CS_OFF_Pos)  /**< (QMSPI_CS_TIMING_REG) This selects the number of system clock cycles between the last clock edge and the deassertion of CS.\n Mask */
#define QMSPI_CS_TIMING_REG_DLY_CLK_STOP_TO_CS_OFF(value) (QMSPI_CS_TIMING_REG_DLY_CLK_STOP_TO_CS_OFF_Msk & ((value) << QMSPI_CS_TIMING_REG_DLY_CLK_STOP_TO_CS_OFF_Pos))
#define QMSPI_CS_TIMING_REG_DLY_LAST_DATA_HOLD_Pos (16)                                           /**< (QMSPI_CS_TIMING_REG) This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD \n    switching from input to output. This is only used if the WP/HOLD functions are in use and only on IO2/WP \n           and IO3/HOLD pins. Position */
#define QMSPI_CS_TIMING_REG_DLY_LAST_DATA_HOLD_Msk (0xFU << QMSPI_CS_TIMING_REG_DLY_LAST_DATA_HOLD_Pos)  /**< (QMSPI_CS_TIMING_REG) This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD \n    switching from input to output. This is only used if the WP/HOLD functions are in use and only on IO2/WP \n           and IO3/HOLD pins. Mask */
#define QMSPI_CS_TIMING_REG_DLY_LAST_DATA_HOLD(value) (QMSPI_CS_TIMING_REG_DLY_LAST_DATA_HOLD_Msk & ((value) << QMSPI_CS_TIMING_REG_DLY_LAST_DATA_HOLD_Pos))
#define QMSPI_CS_TIMING_REG_DLY_CS_OFF_TO_CS_ON_Pos (23)                                           /**< (QMSPI_CS_TIMING_REG) This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum \n           pulse width of CS deassertion. Position */
#define QMSPI_CS_TIMING_REG_DLY_CS_OFF_TO_CS_ON_Msk (0x1FFU << QMSPI_CS_TIMING_REG_DLY_CS_OFF_TO_CS_ON_Pos)  /**< (QMSPI_CS_TIMING_REG) This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum \n           pulse width of CS deassertion. Mask */
#define QMSPI_CS_TIMING_REG_DLY_CS_OFF_TO_CS_ON(value) (QMSPI_CS_TIMING_REG_DLY_CS_OFF_TO_CS_ON_Msk & ((value) << QMSPI_CS_TIMING_REG_DLY_CS_OFF_TO_CS_ON_Pos))
#define QMSPI_CS_TIMING_REG_Msk               (0xFF8F0F0FUL)                                 /**< (QMSPI_CS_TIMING_REG) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_0 : (QMSPI Offset: 0x30) (R/W 32) QMSPI Description Buffer 0 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_0_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_0_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_0) QMSPI Description Buffer 0 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_0) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_0) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_0) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_0_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_0) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_0_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_0) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_0_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_0) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_0_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_0_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_0) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_0) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_0) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_0) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_0) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_0_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_0) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_1 : (QMSPI Offset: 0x34) (R/W 32) QMSPI Description Buffer 1 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_1_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_1_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_1) QMSPI Description Buffer 1 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_1) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_1) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_1) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_1_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_1) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_1_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_1) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_1_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_1) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_1_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_1_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_1) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_1) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_1) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_1) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_1) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_1_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_1) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_2 : (QMSPI Offset: 0x38) (R/W 32) QMSPI Description Buffer 2 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_2_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_2_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_2) QMSPI Description Buffer 2 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_2) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_2) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_2) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_2_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_2) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_2_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_2) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_2_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_2) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_2_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_2_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_2) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_2) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_2) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_2) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_2) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_2_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_2) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_3 : (QMSPI Offset: 0x3c) (R/W 32) QMSPI Description Buffer 3 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_3_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_3_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_3) QMSPI Description Buffer 3 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_3) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_3) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_3) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_3_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_3) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_3_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_3) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_3_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_3) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_3_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_3_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_3) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_3) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_3) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_3) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_3) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_3_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_3) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_4 : (QMSPI Offset: 0x40) (R/W 32) QMSPI Description Buffer 4 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_4_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_4_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_4) QMSPI Description Buffer 4 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_4) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_4) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_4) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_4_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_4) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_4_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_4) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_4_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_4) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_4_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_4_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_4) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_4) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_4) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_4) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_4) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_4_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_4) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_5 : (QMSPI Offset: 0x44) (R/W 32) QMSPI Description Buffer 5 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_5_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_5_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_5) QMSPI Description Buffer 5 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_5_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_5) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_5_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_5_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_5_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_5_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_5) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_5_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_5_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_5_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_5_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_5) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_5_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_5_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_5_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_5_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_5) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_5_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_5) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_5_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_5_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_5_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_5_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_5) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_5_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_5_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_5) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_5) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_5) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_5_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_5) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_5) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_5_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_5_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_5) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_6 : (QMSPI Offset: 0x48) (R/W 32) QMSPI Description Buffer 6 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_6_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_6_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_6) QMSPI Description Buffer 6 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_6_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_6) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_6_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_6_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_6_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_6_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_6) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_6_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_6_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_6_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_6_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_6) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_6_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_6_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_6_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_6_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_6) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_6_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_6) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_6_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_6_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_6_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_6_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_6) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_6_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_6_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_6) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_6) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_6) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_6_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_6) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_6) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_6_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_6_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_6) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_7 : (QMSPI Offset: 0x4c) (R/W 32) QMSPI Description Buffer 7 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_7_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_7_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_7) QMSPI Description Buffer 7 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_7_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_7) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_7_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_7_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_7_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_7_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_7) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_7_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_7_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_7_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_7_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_7) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_7_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_7_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_7_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_7_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_7) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_7_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_7) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_7_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_7_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_7_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_7_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_7) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_7_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_7_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_7) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_7) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_7) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_7_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_7) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_7) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_7_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_7_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_7) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_8 : (QMSPI Offset: 0x50) (R/W 32) QMSPI Description Buffer 8 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_8_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_8_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_8) QMSPI Description Buffer 8 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_8_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_8) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_8_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_8_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_8_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_8_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_8) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_8_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_8_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_8_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_8_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_8) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_8_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_8_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_8_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_8_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_8) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_8_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_8) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_8_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_8_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_8_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_8_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_8) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_8_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_8_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_8) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_8) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_8) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_8_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_8) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_8) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_8_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_8_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_8) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_9 : (QMSPI Offset: 0x54) (R/W 32) QMSPI Description Buffer 9 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_9_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_9_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_9) QMSPI Description Buffer 9 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_9_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_9) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_9_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_9_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_9_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_9_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_9) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_9_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_9_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_9_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_9_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_9) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_9_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_9_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_9_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_9_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_9) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_9_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_9) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_9_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_9_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_9_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_9_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_9) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_9_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_9_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_9) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_9) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_9) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_9_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_9) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_9) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_9_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_9_Msk        (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_9) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_10 : (QMSPI Offset: 0x58) (R/W 32) QMSPI Description Buffer 10 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_10_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_10_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_10) QMSPI Description Buffer 10 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_10_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_10) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_10_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_10_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_10_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_10_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_10) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_10_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_10_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_10_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_10_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_10) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_10_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_10_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_10_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_10_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_10) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_10_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_10) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_10_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_10_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_10_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_10_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_10) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_10_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_10_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_10) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_10) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_10) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_10_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_10) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_10) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_10_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_10_Msk       (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_10) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_11 : (QMSPI Offset: 0x5c) (R/W 32) QMSPI Description Buffer 11 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_11_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_11_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_11) QMSPI Description Buffer 11 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_11_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_11) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_11_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_11_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_11_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_11_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_11) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_11_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_11_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_11_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_11_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_11) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_11_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_11_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_11_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_11_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_11) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_11_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_11) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_11_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_11_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_11_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_11_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_11) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_11_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_11_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_11) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_11) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_11) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_11_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_11) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_11) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_11_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_11_Msk       (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_11) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_12 : (QMSPI Offset: 0x60) (R/W 32) QMSPI Description Buffer 12 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_12_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_12_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_12) QMSPI Description Buffer 12 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_12_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_12) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_12_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_12_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_12_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_12_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_12) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_12_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_12_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_12_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_12_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_12) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_12_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_12_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_12_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_12_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_12) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_12_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_12) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_12_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_12_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_12_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_12_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_12) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_12_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_12_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_12) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_12) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_12) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_12_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_12) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_12) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_12_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_12_Msk       (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_12) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_13 : (QMSPI Offset: 0x64) (R/W 32) QMSPI Description Buffer 13 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_13_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_13_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_13) QMSPI Description Buffer 13 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_13_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_13) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_13_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_13_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_13_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_13_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_13) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_13_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_13_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_13_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_13_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_13) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_13_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_13_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_13_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_13_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_13) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_13_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_13) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_13_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_13_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_13_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_13_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_13) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_13_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_13_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_13) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_13) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_13) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_13_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_13) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_13) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_13_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_13_Msk       (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_13) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_14 : (QMSPI Offset: 0x68) (R/W 32) QMSPI Description Buffer 14 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_14_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_14_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_14) QMSPI Description Buffer 14 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_14_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_14) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_14_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_14_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_14_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_14_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_14) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_14_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_14_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_14_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_14_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_14) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_14_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_14_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_14_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_14_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_14) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_14_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_14) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_14_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_14_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_14_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_14_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_14) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_14_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_14_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_14) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_14) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_14) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_14_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_14) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_14) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_14_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_14_Msk       (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_14) Register Mask  */

/* -------- QMSPI_DESCRIPTION_BUFFER_15 : (QMSPI Offset: 0x6c) (R/W 32) QMSPI Description Buffer 15 Register -------- */

typedef union
{
  struct
  {
    uint32_t INTERFACE_MODE:2;          /**< bit:   0..1  This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. */
    uint32_t TX_TRANSFER_ENABLE:2;      /**< bit:   2..3  This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. */
    uint32_t TX_DMA_ENABLE:2;           /**< bit:   4..5  This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. */
    uint32_t RX_TRANSFER_ENABLE:1;      /**< bit:      6  This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. */
    uint32_t RX_DMA_ENABLE:2;           /**< bit:   7..8  This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. */
    uint32_t CLOSE_TRANFSER_ENABLE:1;   /**< bit:      9  This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active */
    uint32_t TRANSFER_LENGTH_BITS:1;    /**< bit:     10  1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes */
    uint32_t DESCRIPTION_BUFFER_LAST:1;  /**< bit:     11  If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. */
    uint32_t DESCRIPTION_BUFFER_NEXT_POINTER:4;  /**< bit: 12..15  This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. */
    uint32_t TRANSFER_LENGTH:16;        /**< bit: 16..31  The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. */
  };
  uint32_t w;
} __QMSPI_DESCRIPTION_BUFFER_15_bits_t;
#define QMSPI_DESCRIPTION_BUFFER_15_RESETVALUE (0x200U)                                      /**<  (QMSPI_DESCRIPTION_BUFFER_15) QMSPI Description Buffer 15 Register  Reset Value */

#define QMSPI_DESCRIPTION_BUFFER_15_INTERFACE_MODE_Pos (0)                                            /**< (QMSPI_DESCRIPTION_BUFFER_15) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_INTERFACE_MODE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_15_INTERFACE_MODE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_INTERFACE_MODE(value) (QMSPI_DESCRIPTION_BUFFER_15_INTERFACE_MODE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_15_INTERFACE_MODE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_15_TX_TRANSFER_ENABLE_Pos (2)                                            /**< (QMSPI_DESCRIPTION_BUFFER_15) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_TX_TRANSFER_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_15_TX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_TX_TRANSFER_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_15_TX_TRANSFER_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_15_TX_TRANSFER_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_15_TX_DMA_ENABLE_Pos (4)                                            /**< (QMSPI_DESCRIPTION_BUFFER_15) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_TX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_15_TX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_TX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_15_TX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_15_TX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_15_RX_TRANSFER_ENABLE_Pos (6)                                            /**< (QMSPI_DESCRIPTION_BUFFER_15) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_RX_TRANSFER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_15_RX_TRANSFER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_RX_DMA_ENABLE_Pos (7)                                            /**< (QMSPI_DESCRIPTION_BUFFER_15) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_RX_DMA_ENABLE_Msk (0x3U << QMSPI_DESCRIPTION_BUFFER_15_RX_DMA_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_RX_DMA_ENABLE(value) (QMSPI_DESCRIPTION_BUFFER_15_RX_DMA_ENABLE_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_15_RX_DMA_ENABLE_Pos))
#define QMSPI_DESCRIPTION_BUFFER_15_CLOSE_TRANFSER_ENABLE_Pos (9)                                            /**< (QMSPI_DESCRIPTION_BUFFER_15) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCRIPTION_BUFFER_15_CLOSE_TRANFSER_ENABLE_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_15_CLOSE_TRANFSER_ENABLE_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_BITS_Pos (10)                                           /**< (QMSPI_DESCRIPTION_BUFFER_15) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_BITS_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_BITS_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_LAST_Pos (11)                                           /**< (QMSPI_DESCRIPTION_BUFFER_15) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_LAST_Msk (0x1U << QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_LAST_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12)                                           /**< (QMSPI_DESCRIPTION_BUFFER_15) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xFU << QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_NEXT_POINTER_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_NEXT_POINTER(value) (QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_NEXT_POINTER_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_15_DESCRIPTION_BUFFER_NEXT_POINTER_Pos))
#define QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_Pos (16)                                           /**< (QMSPI_DESCRIPTION_BUFFER_15) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_Msk (0xFFFFU << QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_Pos)  /**< (QMSPI_DESCRIPTION_BUFFER_15) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH(value) (QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_Msk & ((value) << QMSPI_DESCRIPTION_BUFFER_15_TRANSFER_LENGTH_Pos))
#define QMSPI_DESCRIPTION_BUFFER_15_Msk       (0xFFFFFFFFUL)                                 /**< (QMSPI_DESCRIPTION_BUFFER_15) Register Mask  */

/** \brief QMSPI register offsets definitions */
#define QMSPI_MODE_OFFSET            (0x00)         /**< (QMSPI_MODE) QMSPI Mode Register Offset */
#define QMSPI_CONTROL_OFFSET         (0x04)         /**< (QMSPI_CONTROL) QMSPI SPI Control Offset */
#define QMSPI_EXECUTE_OFFSET         (0x08)         /**< (QMSPI_EXECUTE) QMSPI Execute Register Offset */
#define QMSPI_INTERFACE_CONTROL_OFFSET (0x0C)         /**< (QMSPI_INTERFACE_CONTROL) QMSPI Interface Control Register Offset */
#define QMSPI_STATUS_OFFSET          (0x10)         /**< (QMSPI_STATUS) QMSPI Status Register Offset */
#define QMSPI_BUFFER_COUNT_STATUS_OFFSET (0x14)         /**< (QMSPI_BUFFER_COUNT_STATUS) QMSPI Buffer Count Status Register Offset */
#define QMSPI_INTERRUPT_ENABLE_OFFSET (0x18)         /**< (QMSPI_INTERRUPT_ENABLE) QMSPI Interrupt Enable Register Offset */
#define QMSPI_BUFFER_COUNT_TRIGGER_OFFSET (0x1C)         /**< (QMSPI_BUFFER_COUNT_TRIGGER) QMSPI Buffer Count Trigger Register Offset */
#define QMSPI_TRAMSMIT_BUFFER_OFFSET (0x20)         /**< (QMSPI_TRAMSMIT_BUFFER) QMSPI Transmit Buffer Register Offset */
#define QMSPI_RECEIVE_BUFFER_OFFSET  (0x24)         /**< (QMSPI_RECEIVE_BUFFER) QMSPI Receive Buffer Register Offset */
#define QMSPI_CS_TIMING_REG_OFFSET   (0x28)         /**< (QMSPI_CS_TIMING_REG) QMSPI Chip Select Timing Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_0_OFFSET (0x30)         /**< (QMSPI_DESCRIPTION_BUFFER_0) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_1_OFFSET (0x34)         /**< (QMSPI_DESCRIPTION_BUFFER_1) QMSPI Description Buffer 1 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_2_OFFSET (0x38)         /**< (QMSPI_DESCRIPTION_BUFFER_2) QMSPI Description Buffer 2 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_3_OFFSET (0x3C)         /**< (QMSPI_DESCRIPTION_BUFFER_3) QMSPI Description Buffer 3 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_4_OFFSET (0x40)         /**< (QMSPI_DESCRIPTION_BUFFER_4) QMSPI Description Buffer 4 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_5_OFFSET (0x44)         /**< (QMSPI_DESCRIPTION_BUFFER_5) QMSPI Description Buffer 5 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_6_OFFSET (0x48)         /**< (QMSPI_DESCRIPTION_BUFFER_6) QMSPI Description Buffer 6 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_7_OFFSET (0x4C)         /**< (QMSPI_DESCRIPTION_BUFFER_7) QMSPI Description Buffer 7 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_8_OFFSET (0x50)         /**< (QMSPI_DESCRIPTION_BUFFER_8) QMSPI Description Buffer 8 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_9_OFFSET (0x54)         /**< (QMSPI_DESCRIPTION_BUFFER_9) QMSPI Description Buffer 9 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_10_OFFSET (0x58)         /**< (QMSPI_DESCRIPTION_BUFFER_10) QMSPI Description Buffer 10 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_11_OFFSET (0x5C)         /**< (QMSPI_DESCRIPTION_BUFFER_11) QMSPI Description Buffer 11 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_12_OFFSET (0x60)         /**< (QMSPI_DESCRIPTION_BUFFER_12) QMSPI Description Buffer 12 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_13_OFFSET (0x64)         /**< (QMSPI_DESCRIPTION_BUFFER_13) QMSPI Description Buffer 13 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_14_OFFSET (0x68)         /**< (QMSPI_DESCRIPTION_BUFFER_14) QMSPI Description Buffer 14 Register Offset */
#define QMSPI_DESCRIPTION_BUFFER_15_OFFSET (0x6C)         /**< (QMSPI_DESCRIPTION_BUFFER_15) QMSPI Description Buffer 15 Register Offset */

/** \brief QMSPI register API structure */
typedef struct
{  /* The Quad SPI Master Controller may be used to communicate with various \n        peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs.\n        The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols. */
  __IO  __QMSPI_MODE_bits_t            QMSPI_MODE;    /**< Offset: 0x00 (R/W  32) QMSPI Mode Register */
  __IO  __QMSPI_CONTROL_bits_t         QMSPI_CONTROL; /**< Offset: 0x04 (R/W  32) QMSPI SPI Control */
  __IO  __QMSPI_EXECUTE_bits_t         QMSPI_EXECUTE; /**< Offset: 0x08 (R/W  32) QMSPI Execute Register */
  __IO  __QMSPI_INTERFACE_CONTROL_bits_t QMSPI_INTERFACE_CONTROL; /**< Offset: 0x0C (R/W  32) QMSPI Interface Control Register */
  __IO  __QMSPI_STATUS_bits_t          QMSPI_STATUS;  /**< Offset: 0x10 (R/W  32) QMSPI Status Register */
  __IO  __QMSPI_BUFFER_COUNT_STATUS_bits_t QMSPI_BUFFER_COUNT_STATUS; /**< Offset: 0x14 (R/W  32) QMSPI Buffer Count Status Register */
  __IO  __QMSPI_INTERRUPT_ENABLE_bits_t QMSPI_INTERRUPT_ENABLE; /**< Offset: 0x18 (R/W  32) QMSPI Interrupt Enable Register */
  __IO  __QMSPI_BUFFER_COUNT_TRIGGER_bits_t QMSPI_BUFFER_COUNT_TRIGGER; /**< Offset: 0x1C (R/W  32) QMSPI Buffer Count Trigger Register */
  __IO  __QMSPI_TRAMSMIT_BUFFER_bits_t QMSPI_TRAMSMIT_BUFFER; /**< Offset: 0x20 (R/W  32) QMSPI Transmit Buffer Register */
  __IO  __QMSPI_RECEIVE_BUFFER_bits_t  QMSPI_RECEIVE_BUFFER; /**< Offset: 0x24 (R/W  32) QMSPI Receive Buffer Register */
  __IO  __QMSPI_CS_TIMING_REG_bits_t   QMSPI_CS_TIMING_REG; /**< Offset: 0x28 (R/W  32) QMSPI Chip Select Timing Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_0_bits_t QMSPI_DESCRIPTION_BUFFER_0; /**< Offset: 0x30 (R/W  32) QMSPI Description Buffer 0 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_1_bits_t QMSPI_DESCRIPTION_BUFFER_1; /**< Offset: 0x34 (R/W  32) QMSPI Description Buffer 1 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_2_bits_t QMSPI_DESCRIPTION_BUFFER_2; /**< Offset: 0x38 (R/W  32) QMSPI Description Buffer 2 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_3_bits_t QMSPI_DESCRIPTION_BUFFER_3; /**< Offset: 0x3C (R/W  32) QMSPI Description Buffer 3 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_4_bits_t QMSPI_DESCRIPTION_BUFFER_4; /**< Offset: 0x40 (R/W  32) QMSPI Description Buffer 4 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_5_bits_t QMSPI_DESCRIPTION_BUFFER_5; /**< Offset: 0x44 (R/W  32) QMSPI Description Buffer 5 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_6_bits_t QMSPI_DESCRIPTION_BUFFER_6; /**< Offset: 0x48 (R/W  32) QMSPI Description Buffer 6 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_7_bits_t QMSPI_DESCRIPTION_BUFFER_7; /**< Offset: 0x4C (R/W  32) QMSPI Description Buffer 7 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_8_bits_t QMSPI_DESCRIPTION_BUFFER_8; /**< Offset: 0x50 (R/W  32) QMSPI Description Buffer 8 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_9_bits_t QMSPI_DESCRIPTION_BUFFER_9; /**< Offset: 0x54 (R/W  32) QMSPI Description Buffer 9 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_10_bits_t QMSPI_DESCRIPTION_BUFFER_10; /**< Offset: 0x58 (R/W  32) QMSPI Description Buffer 10 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_11_bits_t QMSPI_DESCRIPTION_BUFFER_11; /**< Offset: 0x5C (R/W  32) QMSPI Description Buffer 11 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_12_bits_t QMSPI_DESCRIPTION_BUFFER_12; /**< Offset: 0x60 (R/W  32) QMSPI Description Buffer 12 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_13_bits_t QMSPI_DESCRIPTION_BUFFER_13; /**< Offset: 0x64 (R/W  32) QMSPI Description Buffer 13 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_14_bits_t QMSPI_DESCRIPTION_BUFFER_14; /**< Offset: 0x68 (R/W  32) QMSPI Description Buffer 14 Register */
  __IO  __QMSPI_DESCRIPTION_BUFFER_15_bits_t QMSPI_DESCRIPTION_BUFFER_15; /**< Offset: 0x6C (R/W  32) QMSPI Description Buffer 15 Register */
} qmspi_registers_t;
/** @}  end of The Quad SPI Master Controller may be used to communicate with various \n        peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs.\n        The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols. */

#endif /* _PIC32CX_0525SG12_QMSPI_COMPONENT_H_ */
